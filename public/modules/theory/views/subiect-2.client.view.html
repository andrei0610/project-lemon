<section data-ng-controller="Subiect2Controller">
	<div id="content">
		<h2 class="text-center"> Subiectul II </h2>
		<span>Subiectul II cuprinde exercitii bazate pe teoria din:<a href="#subprog"> functii (subprograme) </a>, <a href="sub2-pag4.html">backtracking </a>, grafuri (<a href="sub2-pag5.html">neorientate</a> si <a href="sub2-pag6.html">orientate</a>) si <a href="sub2-pag7.html"> arbori</a>.</span>

		<h3 id="#subprog" class="text-center">1.Functii(subprograme)</h3>
		<p>O <em>funcţie</em> (<em>subprogram</em>) este un grup de instrucţiuni apelabil (invocabil) din alte părţi ale programului. De exemplu, <strong>main</strong> este o funcţie.<br/>
		A apela o funcţie înseamnă a o executa.<br/>
		Funcţiile ajută la modularizarea programului, la structurarea acestuia în unităţi logice.<br/>
		O funcţie se declară în felul următor:
		<pre>&#09&#09tip nume(lista_param); //Prototipul functiei</pre>
		Exemplu:
		<pre>&#09&#09int suma(int a, int b);</pre>
		<code>lista_param</code> - lista de parametri, despărţiţi prin virgulă, este opţională. <br/>
		Parantezele sunt obligatorii. Ele deosebesc funcţiile de alte entităţi C++ (de exemplu, variabile).
		<pre>&#09&#09void nimic(); //functie fara parametri</pre>
		Tipul <code>void</code> reprezintă absenţa tipului. Cu alte cuvinte, funcţiile care nu returnează nicio valoare, au tipul <code>void</code>.<br/>
		Funcţiile pot returna valori codului apelant (locul de unde a fost apelată funcţia) prin intermediul instrucţiunii <code>return</code>. <br/>
		După declarare, o funcţie trebuie definită undeva în program.
		<pre>&#09&#09#include &lt;iostream&gt;
		using namespace std;

		int suma(int, int); //Declarare

		int main()
		{
		    int x, y;
		    cout&lt;&lt;&quot;Da-mi doua numere intregi: &quot;;
		    cin &gt;&gt; x &gt;&gt; y;
		    cout&lt;&lt;&quot;Suma lor este &quot;&lt;&lt;suma(x, y);
		    return 0;
		}

		int suma(int a, int b) //Definire
		{
		    int rezultat=a + b;
		    //Puteam scrie direct
		    //return a+b;
		    return rezultat;
		}</pre>
		Când declaraţi o funcţie, puteţi omite numele parametrilor (aşa cum am făcut în exemplu), dar trebuie să precizaţi tipul lor. <br/>
		Parametrii sunt variabile locale funcţiei (vizibile numai în blocul funcţiei). <br/>
		Instrucţiunea <code>return</code> întrerupe execuţia funcţiei şi returnează valoarea expresiei, din dreapta, codului apelant. <br/>
		Într-o funcţie puteţi avea mai multe instrucţiuni <code>return</code>. <br/>
		Observaţi cum se apelează o funcţie: <code>suma(x, y);</code>.
		Dacă funcţia nu are parametri, se apelează doar cu nume + paranteze: <code>funcFaraParam();</code>.<br/>
		Când execuţia unei funcţii se termină, controlul programului revine în punctul apelării şi programul îşi continuă execuţia normal. <br/>
		Funcţiile <code>void</code> nu returnează valori, ele doar îndeplinesc o sarcină, deci nu pot avea instrucţiunea <code>return expr;</code>. <br/>
		Puteţi însă folosi <code>return;</code> ca să întrerupeţi execuţia unei funcţii <code>void</code>.
		<pre>&#09&#09#include &lt;iostream&gt;
		using namespace std;

		//Declarare + Definire
		void afiseazaText()
		{
		    for (int i=0; i &lt; 5; i++)
		        cout&lt;&lt;&quot;Hello functions!&quot;;
		}

		int main()
		{
		    //Se va afisa de 5 ori textul:
		    //Hello functions!
		    afiseazaText();
		    return 0;
		}</pre>
		Puteţi declara şi defini o funcţie în acelaşi loc, dar <strong>numai</strong> înainte de <strong>main</strong>, altfel compilatorul nu va recunoaşte funcţia. <br/>
		Funcţiile <code>void</code> nu pot fi folosite în expresii, deoarece expresiile au în componenţa lor operatori care aşteaptă valori, ori o funcţie <code>void</code> nu returnează nicio valoare. <br/>
		O funcţie poate avea orice număr de parametri. <br/>
		Variabilele declarate într-o funcţie sunt locale, adică sunt vizibile numai în respectiva funcţie. Ele nu pot fi folosite în afara ei (valabil şi pentru parametri). <br/>
		Argumentele funcţiei sunt datele (variabile, expresii, constante, etc.) transmise funcţiei şi primite de parametrii acesteia.<br/>
		De exemplu, în apelul <code>suma(x, y);</code> argumentele sunt variabilele <code>x</code> şi <code>y</code>. </p>
		<p>Parametrii unei funcţii pot avea valori implicite (default). Parametrii default trebuie poziţionaţi la sfârşitul listei de parametri.<br/>
		După ce aţi declarat un parametru implicit, nu mai aveţi voie să declaraţi parametri normali în continuare acestuia, ci doar parametri impliciţi.
		<pre>&#09&#09#include &lt;iostream&gt;
		using namespace std;

		double arieCerc(double raza, double PI=3.14)
		{
		    return 2*PI*raza*raza;
		}

		int main()
		{
		    cout&lt;&lt;&quot;Aria cercului de raza 2 este &quot;&lt;&lt;arieCerc(2.0)&lt;&lt;'\n'; //PI==3.14
		    cout&lt;&lt;&quot;Aria cercului de raza 2 este &quot;&lt;&lt;arieCerc(2.0, 3.141592);
		    return 0;
		}</pre>
		Se va afişa
		<pre>&#09&#09Aria cercului de raza 2 este 25.12
		Aria cercului de raza 2 este 25.1327</pre>
		Când nu transmiteţi o valoare parametrului implicit, compilatorul va folosi valoarea implicită, dată de voi.
<!--Aici incepe pagina 2. Schimba aici tagu pentru subiectu 2.-->


		<p><a class=""> Transmiterea prin valoare si prin referinta</a> </p>
		<p>Atunci când transmiteţi argumente (şi sunt variabile) unei funcţii, transmiteţi de fapt o copie a acelor variabile. <br/>
		Aceasta este transmiterea prin valoare (<em>pass by value</em>). <br/>
		Orice modificare a parametrilor unei funcţii este vizibilă numai în acea funcţie. <br/>
		Variabilele - folosite ca argumente - rămân nemodificate.
		<pre>&#09&#09#include &lt;iostream&gt;
		using namespace std;

		void modifica(int a)
		{
		    a=a + 5;
		    cout&lt;&lt;&quot;a are valoarea: &quot;&lt;&lt;a&lt;&lt;'\n';
		}

		int main()
		{
		    int x=1;
		    cout&lt;&lt;&quot;x inainte de apel: &quot;&lt;&lt;x&lt;&lt;'\n';
		    modifica(x);
		    cout&lt;&lt;&quot;x dupa apel: &quot;&lt;&lt;x;
		    return 0;
		}</pre>
		Output:
		<pre>&#09&#09x inainte de apel: 1
			a are valoarea: 6
			x dupa apel: 1</pre>
		O funcţie poate returna decât o singură valoare printr-un <code>return</code>, ca la matematică. <br/>
		Uneori vrem ca o funcţie să poată returna mai multe valori. Un mod prin care putem obţine acest lucru este transmiterea prin referinţă (<em>pass by reference</em>). <br/>
		Atunci când transmiteţi prin referinţă, parametrii funcţiei alterează direct conţinutul variabilelor argumente (nu mai există nicio copie). <br/>
		Ca să transmiteţi prin referinţă folosiţi ampersand (<code>&amp;</code>) între tipul parametrului şi numele acestuia. <br/>
		Parametrii referinţă acceptă numai variabile. <strong>NU</strong> acceptă constante (deoarece nu pot fi alterate)!
		<pre>&#09&#09#include &lt;iostream&gt;
		using namespace std;

		void modifica(int&amp; a) //Nu uitati de ampersand !
		{
		    a=a + 5;
		    cout&lt;&lt;&quot;a are valoarea: &quot;&lt;&lt;a&lt;&lt;'\n';
		}

		int main()
		{
		    int x=1;
		    cout&lt;&lt;&quot;x inainte de apel: &quot;&lt;&lt;x&lt;&lt;'\n';
		    modifica(x);
		    cout&lt;&lt;&quot;x dupa apel: &quot;&lt;&lt;x;
		    return 0;
		}</pre>
		Output:
		<pre>&#09&#09
		x inainte de apel: 1
		a are valoarea: 6
		x dupa apel: 6</pre>
		</p>

		<p>!<u> Observatie </u>: <strong>Vectorii</strong> se transmit prin referinţă! <br>
		<pre>&#09&#09#include &lt;iostream&gt;
		using namespace std;

		void modifica(int v[], int l)
		{
		    for (int i=0; i &lt; l; i++)
		        v[i] += 5; //v[i]=v[i] + 5;
		}

		int main()
		{
		    int w[]={1, 2, 3, 4}, k=4;
		    modifica(w, k);

		    for (int i=0; i &lt; k; i++)
		        cout &lt;&lt;w[i]&lt;&lt;' ';

		    return 0;
		}</pre>
		Output:
		<pre>&#09&#09 6 7 8 9</pre>
		Observaţi cum se transmite un vector ca parametru. <br/>
		Numărul de elemente poate lipsi (valabil doar pentru prima dimensiune). <br/>
		Dacă aş fi avut o matrice de <code>2 x 3</code>, atunci aş fi scris:
		<pre>&#09&#09void modifica(int v[][3],...)...</pre>
		</p><br/>

<!-- Aici incepe pagina 3 -->
		<div class="block">
		  <div class="label label-info">
		    <span>Functii recursive</span>
		  </div>
		</div>
		<span>O funcţie care se autoapelează se numeşte <em>recursivă</em>. <br/>
		Aveţi grijă ca funcţia să aibă o condiţie de terminare, altfel puteţi crea o repetiţie infinită. <br/>
		Parametrii funcţiilor şi variabilele locale sunt încărcate, stocate, pe Stivă (o regiune din memorie structurată pe principiul stivei, LIFO), iar în cazul unei funcţii recursive infinite, Stiva se poate umple repede (<em>stack overflow</em>) cauzând un crash al programului. <br/>
		Factorialul unui număr poate fi calculat cu o funcţie recursivă (deşi se poate face acelaşi lucru şi cu un loop).
		<pre >&#09&#09#include &lt;iostream&gt;
		using namespace std;

		int fact(int n)
		{
			//Conditia de terminare
		    if (n==0) 
		        return 1;
		    else
		        return n*fact(n-1);
		}

		int main()
		{
		    cout&lt;&lt;fact(0)&lt;&lt;'\n';
		    cout&lt;&lt;fact(3)&lt;&lt;'\n';
		    cout&lt;&lt;fact(8)&lt;&lt;'\n';
		    return 0;
		}</pre>
		Output:
		<pre>&#09&#09 
		1
		6
		40320</pre>
		Ca să înţelegeţi mai bine mecanismul recursivităţii vizionaţi acest clip de pe Youtube:
		<p style="text-align:center;"><iframe width="640" height="360" src="http://www.youtube.com/embed/k0bb7UYy0pY" frameborder="0" allowfullscreen></iframe></p>
		</span><br/>
<!-- Aici incepe pagina 4 -->
  		<h3 id="#backtracking" class="text-center">2.Backtracking</h3>
	 	<p><b> Backtracking </b> este o metoda de parcurgere sistematica a spatiului solutiilor posibile al unei probleme. <br>
		Este o metoda generala de programare, si poate fi adaptata pentru orice problema pentru care dorim sa obtinem toate solutiile posibile, sau sa selectam o solutie optima, din multimea solutiilor posibile. <br>
		Backtracking este insa si cea mai costisitoare metoda din punct de vedere al timpului de executie. </p>
	    <p> In general vom modela solutia problemei ca un vector <b> v=(v<sub>1</sub>, v<sub>2</sub>,...,v<sub>n</sub> )</b> in care fiecare element <b>v<sub>k</sub></b> apartine unei multimi finite si ordonate <b>S<sub>k</sub> cu k=1,n</b>. In anumite cazuri multimile <b>S<sub>1</sub>, S<sub>2</sub>,...,S<sub>n</sub></b> pot fi identice.<br>
		Procedam astfel: <br>
		<ol>
		<li> La fiecare pas k pornim de la o solutie partiala v=(v<sub>1</sub>, v<sub>2</sub>,...,v<sub>n</sub> ) si incercam sa extindem aceasta solutie adaugand un nou element la sfarsitul vectorului. </li>
		<li> Cautam in multimea S<sub>k</sub> un nou element.</li>
		<li> Daca exista un element neselectat inca, verificam daca acest element indeplineste conditiile impuse de problema, numite <b>conditii de continuare </b>.</li>
		<li> Daca sunt respectat conditiile de continuare, adaugam elementul solutiei partiale.</li>
		<li> Verificam daca am obtinut o solutie completa.
		       <ul style="list-style-type:square">
			     <li> daca am obtinut o solutie completa o afisam si se reia algoritmul de la pasul 1</li>
				 <li> daca nu am obtinut o solutie, k &lt;- k+1 si se reia algoritmul de la pasul 1</li>
			   </ul> </li>
	    <li> Daca nu sunt indeplinite conditiile de continuare se reia algoritmul de la pasul 2.</li>
		<li> Daca nu mai exista niciun element neverificat in multime S<sub>k</sub> inseamna ca nu mai avem nicio posibilitate din acest moment, sa construim solutia finala asa ca trebuie sa modificam alegerile facute in prealabil, astfel k&lt;-k-1 si se reia problema de la pasul 1.</li>
		</ol> <br>
		Revenirea in caz de insucces sau pentru generarea tuturor solutiilor problemei, a condus la denumirea de "backtracking" a metodei, traducerea aproximativa ar fi "revenire in urma".
		</p> <br>

		<div class="block">
		  <div class="label label-info">
		    <span>Exemplu: PERMUTARI</span>
		  </div>
		</div>
	    <p> Sa se genereze toate permutarile primelor <b>n</b> numere naturale. <br>
		 Vom selecta pe rand solutiile problemei in vectorul <b> v=(v<sub>1</sub>, v<sub>2</sub>,...,v<sub>n</sub> )</b> unde <b>v<sub>k</sub> </b> este din <b>S<sub>k</sub></b>. <br>
		 Sa facem urmatoarele observatii: 
		 <ol>
		 <li> Pentru aceasta problema toate multimile <b>S<sub>k</sub></b> sunt identice, cu <b>S<sub>k</sub>={1,2,3,...,n}</b>. La pasul <b>k</b> selectam un element din multimea <b>S<sub>k</sub></b>. </li>
		 <li> Intrucat in cadrul unei permutari <b> elementele nu au voie sa se repete </b> aceasta conditie reprezinta conditia de continuare a problemei. </li>
		 <li> Obtinem o solutie in momentul in care completam vectorul cu <b>n</b> elemente.</li>
		 </ol> 
	    </p>
	    <p> Exemplu pentru n=3.<br>
		<b>S<sub>1</sub> = S<sub>2</sub> = S<sub>3</sub> = {1,2,3}.</b> <br>
		Solutiile sunt: (1, 2, 3) (1, 3, 2) (2, 1, 3) (2, 3, 1) (3, 1, 2) (3, 2, 1). <br>
		<!-- Din nu stiu care motiv, nu merge srcu asta. -->
		<img src="public/modules/theory/images/permutari.png"></img>
		</p>
<!-- Aici incepe pagina 5. -->
		<h3 id="#grafuri" class="text-center">3.Grafuri</h3>
		<div class="block">
		  <div class="label label-info">
		    <span>Grafuri neorientate</span>
		  </div>
		</div>
		<p>
		Definitie: Se numeste <b>graf neorientat</b> G o pereche ordonata de multimi (X,U), unde X este o multime finita si nevida de elemente, iar U o multime de perechi formate cu elemente distincte din multimea X.
	    <br>
		G= (V,U) <br>
		<u>Exemplu </u> : <br>
		V = {1,2,3,4,5,6,7} <br> U = {(1,2),(2,3),(3,7),(7,5),(1,6),(7,1),(2,5),(2,7)} <br>
		
		<img src="images/ex-graf-neorientat.jpg"  > Fig.1  </img>
		</p>
		
		<p>
		<a class="purple_text"> Terminologie </a> <br>
		<ul style="list-style-type:circle">
		<li> Elementele multimii V se numesc <b> noduri </b> sau <b>varfuri </b> . Multimea V se mai numeste si multimea nodurilor sau varfurilor. </li>
		<li> Elementele multimii U se numesc <b>muchii</b>. Multimea U se mai numeste si multimea muchiilor.</li>
		<li> Ordinul grafului reprezinta numarul de noduri ale grafului. </li>
		<li> Numim <b>noduri adiacente</b> orice pereche de noduri care formeaza o muchie. Fiecare din cele doua noduri spunem, ca sunt incidente cu muchia pe care o formeaza.</li>
	     <br>
		Exemplu: <br>
		Nodul 1 este adiacent cu nodurile 2,6,7; nodul 5 este adiacent cu nodurile 2,7 etc. <br>
		Nodurile 3,7 sunt incidente cu muchia (3,7). <br> <br>
	    <li> Nodurile <b>vecine </b> ale unui nod sunt toate nodurile adiacente cu el. </li>
		<li> Se numesc muchii incidente doua muchii care au extremitate comuna.</li> <br>
		Exemplu: <br>
		Muchiile (1,2) si (2,7) sunt incidente avand ca extremitate comuna nodul 2. 
		</ul> <br><br>
		<u> Definitie  </u> :<b>Gradul unui nod x </b> al grafului este egal cu numarul muchiilor incidente cu nodul si se noteaza cu <b>d(x) </b>.
	    <br>
		Exemplu: <br>

	    d(1)=3;d(2)=4;d(3)=2 etc. (Fig.1)<br><br>
		<li> Se numeste <b>nod terminal </b> un nod care are gradul egal cu 1. </li>
		<li> Se numeste un <b>nod izolat</b> un nod care are gradul 0. </li>
		</ul>
		</p>
		
		<p> <a class="orange_text"> Teoreme </a> <br>
		<ol>
		<li> Numarul total de grafuri neorientate cu n noduri este: <br> <img src="images/gr-neor-1.jpg"></img></li>
		<li> Suma gradelor tuturor nodurilor unui garf neorientat este egala cu dublul nuamrului de muchii. <br> <img src="images/gr-neor-2.jpg"></img></li>
		<li> Daca gaful G neorientat are n noduri, n>2, atunci cel putin 2 noduri au acelasi grad.   </li>
		<li> Pentru orice graf neorientat numarul nodurilor de gard impar este par.</li>
		<li> Numarul minim de muchii pe care trebuie sa le aiba n graf neorientat cu n noduri , ca sa nu existe noduri izolate este: <br> <img src="images/gr-neor-5.jpg"></img> </li>
		</ol>
		</p>
		
		<p> <a class="orange_text"> Lanturi intr-un graf neorientat </a> <br><br>
		<u>Definitie </u> : Se numeste <b>lant</b> intr-un graf neorientat o succesiune de varfuri cu proprietatea ca intre oricare doua varfuri alaturate exista o muchie. 
		<br>
		Exemplu: <br> {6,1,7,5,2,3} reprezinta un  lant. (Fig.1)<br><br>
		<a class="purple_text"> Terminologie</a>
		<ul style="list-style-type:circle">
		<li> Numim <b>lant elementar </b> o succesune de varfuri care respecta proprietatea de lant si in care oricare doua varfuri sunt distincte. In caz contrar lantul se numeste <b>neelementar</b>.</li>
		<li> Se numeste <b>lant simplu </b> o succesiune de  varfuri cu proprietatea ca fiecare muchie este vizitata o singura data. </li>
		<li> Se numeste lant <b>compus</b> un lant in care o muchie este vizitata de cel putin doua ori. </li>
		<li> Se numeste <b>ciclu </b> int-un lant o succesiune de varfuri cu proprietatea ca primul nod coincide cu ultimul nod.</li>
		
		</ul>
		<br>
		
	    Exemplu:  <br>

	   {6,1,7,2} reprezinta un lant elementar. <br>

	  {6,1,7,5,2,7,3} reprezinta lant neelementar. <br>

	  {2,3,7,5} reprezinta lant simplu. <br>

	  {5,2,7,5,2,3} reprezinta lant compus. <br>

	  {5,2,7,5} reprezinta ciclu intr-un lant. (Fig.1)
		
		</p> <br>
		
		<p>
		<a class="orange_text"> Grafuri derivate</a> <br><br>
		<u>Definitie </u> : Se numeste <b>graf partial </b> notat cu Gp=(V,U'), cu proprietatea ca multimea U' de perechi de varfuri este inclusa in multimea U.
		<br>
		G={V,U} <br>

	   V={1,2,3,4,5,6,7} <br>

	   U={(1,6),(1,7),(2,3),(2,5),(3,7),(5,7)} <br>
	   <img src="images/ex-graf-neorientat.jpg"> </img> <br>
	   
	   <u> Definitie </u> : Un <b>subgraf</b> al unui graf neorientat G=(V,U) este un graf H=(V',U') astfel incât V' inclus in V şi U' conţine toate muchiile din U care au ambele extremităţi în V' (poate fi graful iniţial sau se obţine din acesta prin eliminarea unor vârfuri şi a muchiilor incidente cu acestea). 
		
		</p> <br>
		
		<p><a class="orange_text"> Grafuri speciale </a> <br> <br>
		<b>Graful null </b> este garful in care multimea U este vida. <br>
		<img src="images/graf-neor-null.jpg"> </img> <br>
		<b>Graful complet cu n noduri </b> este graful care are intre oricare doua noduri adiacente o muchie  .<br>
		<img src="images/graf-neor-complet.jpg"> </img> <br>
		<b>Graful conex </b> este un graf care are intre oricare doua noduri un lant care sa le uneasca. <br>
		<img src="images/graf-neor-conex.jpg"> </img>
		</p>


	</div>
</section>