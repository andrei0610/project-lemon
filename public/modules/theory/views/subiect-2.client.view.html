<section data-ng-controller="Subiect2Controller">
	<div id="content">
		<h2 class="text-center"> Subiectul II </h2>
		<span>Subiectul II cuprinde exercitii bazate pe teoria din:<a href="#subprog"> functii (subprograme) </a>, <a href="sub2-pag4.html">backtracking </a>, grafuri (<a href="sub2-pag5.html">neorientate</a> si <a href="sub2-pag6.html">orientate</a>) si <a href="sub2-pag7.html"> arbori</a>.</span>

		<h3 id="#subprog" class="text-center">1.Functii(subprograme)</h3>
		<p>O <em>funcţie</em> (<em>subprogram</em>) este un grup de instrucţiuni apelabil (invocabil) din alte părţi ale programului. De exemplu, <strong>main</strong> este o funcţie.<br/>
		A apela o funcţie înseamnă a o executa.<br/>
		Funcţiile ajută la modularizarea programului, la structurarea acestuia în unităţi logice.<br/>
		O funcţie se declară în felul următor:
		<pre>tip nume(lista_param); //Prototipul functiei</pre>
		Exemplu:
		<pre>int suma(int a, int b);</pre>
		<code>lista_param</code> - lista de parametri, despărţiţi prin virgulă, este opţională. <br/>
		Parantezele sunt obligatorii. Ele deosebesc funcţiile de alte entităţi C++ (de exemplu, variabile).
		<pre>void nimic(); //functie fara parametri</pre>
		Tipul <code>void</code> reprezintă absenţa tipului. Cu alte cuvinte, funcţiile care nu returnează nicio valoare, au tipul <code>void</code>.<br/>
		Funcţiile pot returna valori codului apelant (locul de unde a fost apelată funcţia) prin intermediul instrucţiunii <code>return</code>. <br/>
		După declarare, o funcţie trebuie definită undeva în program.
		<pre>#include &lt;iostream&gt;
		using namespace std;

		int suma(int, int); //Declarare

		int main()
		{
		    int x, y;
		    cout&lt;&lt;&quot;Da-mi doua numere intregi: &quot;;
		    cin &gt;&gt; x &gt;&gt; y;
		    cout&lt;&lt;&quot;Suma lor este &quot;&lt;&lt;suma(x, y);
		    return 0;
		}

		int suma(int a, int b) //Definire
		{
		    int rezultat=a + b;
		    //Puteam scrie direct
		    //return a+b;
		    return rezultat;
		}</pre>
		Când declaraţi o funcţie, puteţi omite numele parametrilor (aşa cum am făcut în exemplu), dar trebuie să precizaţi tipul lor. <br/>
		Parametrii sunt variabile locale funcţiei (vizibile numai în blocul funcţiei). <br/>
		Instrucţiunea <code>return</code> întrerupe execuţia funcţiei şi returnează valoarea expresiei, din dreapta, codului apelant. <br/>
		Într-o funcţie puteţi avea mai multe instrucţiuni <code>return</code>. <br/>
		Observaţi cum se apelează o funcţie: <code>suma(x, y);</code>.
		Dacă funcţia nu are parametri, se apelează doar cu nume + paranteze: <code>funcFaraParam();</code>.<br/>
		Când execuţia unei funcţii se termină, controlul programului revine în punctul apelării şi programul îşi continuă execuţia normal. <br/>
		Funcţiile <code>void</code> nu returnează valori, ele doar îndeplinesc o sarcină, deci nu pot avea instrucţiunea <code>return expr;</code>. <br/>
		Puteţi însă folosi <code>return;</code> ca să întrerupeţi execuţia unei funcţii <code>void</code>.
		<pre>#include &lt;iostream&gt;
		using namespace std;

		//Declarare + Definire
		void afiseazaText()
		{
		    for (int i=0; i &lt; 5; i++)
		        cout&lt;&lt;&quot;Hello functions!&quot;;
		}

		int main()
		{
		    //Se va afisa de 5 ori textul:
		    //Hello functions!
		    afiseazaText();
		    return 0;
		}</pre>
		Puteţi declara şi defini o funcţie în acelaşi loc, dar <strong>numai</strong> înainte de <strong>main</strong>, altfel compilatorul nu va recunoaşte funcţia. <br/>
		Funcţiile <code>void</code> nu pot fi folosite în expresii, deoarece expresiile au în componenţa lor operatori care aşteaptă valori, ori o funcţie <code>void</code> nu returnează nicio valoare. <br/>
		O funcţie poate avea orice număr de parametri. <br/>
		Variabilele declarate într-o funcţie sunt locale, adică sunt vizibile numai în respectiva funcţie. Ele nu pot fi folosite în afara ei (valabil şi pentru parametri). <br/>
		Argumentele funcţiei sunt datele (variabile, expresii, constante, etc.) transmise funcţiei şi primite de parametrii acesteia.<br/>
		De exemplu, în apelul <code>suma(x, y);</code> argumentele sunt variabilele <code>x</code> şi <code>y</code>. </p>
		<p>Parametrii unei funcţii pot avea valori implicite (default). Parametrii default trebuie poziţionaţi la sfârşitul listei de parametri.<br/>
		După ce aţi declarat un parametru implicit, nu mai aveţi voie să declaraţi parametri normali în continuare acestuia, ci doar parametri impliciţi.
		<pre >#include &lt;iostream&gt;
		using namespace std;

		double arieCerc(double raza, double PI=3.14)
		{
		    return 2*PI*raza*raza;
		}

		int main()
		{
		    cout&lt;&lt;&quot;Aria cercului de raza 2 este &quot;&lt;&lt;arieCerc(2.0)&lt;&lt;'\n'; //PI==3.14
		    cout&lt;&lt;&quot;Aria cercului de raza 2 este &quot;&lt;&lt;arieCerc(2.0, 3.141592);
		    return 0;
		}</pre>
		Se va afişa
		<pre>Aria cercului de raza 2 este 25.12
		Aria cercului de raza 2 este 25.1327</pre>
		Când nu transmiteţi o valoare parametrului implicit, compilatorul va folosi valoarea implicită, dată de voi.
<!--Aici incepe pagina 2. Schimba aici tagu pentru subiectu 2.-->


		<p><a class=""> Transmiterea prin valoare si prin referinta</a> </p>
		<p>Atunci când transmiteţi argumente (şi sunt variabile) unei funcţii, transmiteţi de fapt o copie a acelor variabile. <br/>
		Aceasta este transmiterea prin valoare (<em>pass by value</em>). <br/>
		Orice modificare a parametrilor unei funcţii este vizibilă numai în acea funcţie. <br/>
		Variabilele - folosite ca argumente - rămân nemodificate.
		<pre>#include &lt;iostream&gt;
		using namespace std;

		void modifica(int a)
		{
		    a=a + 5;
		    cout&lt;&lt;&quot;a are valoarea: &quot;&lt;&lt;a&lt;&lt;'\n';
		}

		int main()
		{
		    int x=1;
		    cout&lt;&lt;&quot;x inainte de apel: &quot;&lt;&lt;x&lt;&lt;'\n';
		    modifica(x);
		    cout&lt;&lt;&quot;x dupa apel: &quot;&lt;&lt;x;
		    return 0;
		}</pre>
		Output:
		<pre>x inainte de apel: 1
		a are valoarea: 6
		x dupa apel: 1</pre>
		O funcţie poate returna decât o singură valoare printr-un <code>return</code>, ca la matematică. <br/>
		Uneori vrem ca o funcţie să poată returna mai multe valori. Un mod prin care putem obţine acest lucru este transmiterea prin referinţă (<em>pass by reference</em>). <br/>
		Atunci când transmiteţi prin referinţă, parametrii funcţiei alterează direct conţinutul variabilelor argumente (nu mai există nicio copie). <br/>
		Ca să transmiteţi prin referinţă folosiţi ampersand (<code>&amp;</code>) între tipul parametrului şi numele acestuia. <br/>
		Parametrii referinţă acceptă numai variabile. <strong>NU</strong> acceptă constante (deoarece nu pot fi alterate)!
		<pre>#include &lt;iostream&gt;
		using namespace std;

		void modifica(int&amp; a) //Nu uitati de ampersand !
		{
		    a=a + 5;
		    cout&lt;&lt;&quot;a are valoarea: &quot;&lt;&lt;a&lt;&lt;'\n';
		}

		int main()
		{
		    int x=1;
		    cout&lt;&lt;&quot;x inainte de apel: &quot;&lt;&lt;x&lt;&lt;'\n';
		    modifica(x);
		    cout&lt;&lt;&quot;x dupa apel: &quot;&lt;&lt;x;
		    return 0;
		}</pre>
		Output:
		<pre>x inainte de apel: 1
		a are valoarea: 6
		x dupa apel: 6</pre>
		</p>

		<p>!<u> Observatie </u> : <strong>Vectorii</strong> se transmit prin referinţă! <br>
		<pre>#include &lt;iostream&gt;
		using namespace std;

		void modifica(int v[], int l)
		{
		    for (int i=0; i &lt; l; i++)
		        v[i] += 5; //v[i]=v[i] + 5;
		}

		int main()
		{
		    int w[]={1, 2, 3, 4}, k=4;
		    modifica(w, k);

		    for (int i=0; i &lt; k; i++)
		        cout &lt;&lt;w[i]&lt;&lt;' ';

		    return 0;
		}</pre>
		Output:
		<pre>6 7 8 9</pre>
		Observaţi cum se transmite un vector ca parametru. <br/>
		Numărul de elemente poate lipsi (valabil doar pentru prima dimensiune). <br/>
		Dacă aş fi avut o matrice de <code>2 x 3</code>, atunci aş fi scris:
		<pre>void modifica(int v[][3], ...) ...</pre>
		</p><br/>

<!-- Aici incepe pagina 3 -->
		<p><a class="in_box"> Functii recursive </a> </p>
		<p>O funcţie care se autoapelează se numeşte <em>recursivă</em>. <br/>
		Aveţi grijă ca funcţia să aibă o condiţie de terminare, altfel puteţi crea o repetiţie infinită. <br/>
		Parametrii funcţiilor şi variabilele locale sunt încărcate, stocate, pe Stivă (o regiune din memorie structurată pe principiul stivei, LIFO), iar în cazul unei funcţii recursive infinite, Stiva se poate umple repede (<em>stack overflow</em>) cauzând un crash al programului. <br/>
		Factorialul unui număr poate fi calculat cu o funcţie recursivă (deşi se poate face acelaşi lucru şi cu un loop).
		<pre  >#include &lt;iostream&gt;
		using namespace std;

		int fact(int n)
		{
			//Conditia de terminare
		    if (n==0) 
		        return 1;
		    else
		        return n*fact(n-1);
		}

		int main()
		{
		    cout&lt;&lt;fact(0)&lt;&lt;'\n';
		    cout&lt;&lt;fact(3)&lt;&lt;'\n';
		    cout&lt;&lt;fact(8)&lt;&lt;'\n';
		    return 0;
		}</pre>
		Output:
		<pre>1
		6
		40320</pre>
		Ca să înţelegeţi mai bine mecanismul recursivităţii vizionaţi acest clip de pe Youtube:
		<p style="text-align:center;"><iframe width="640" height="360" src="http://www.youtube.com/embed/k0bb7UYy0pY" frameborder="0" allowfullscreen></iframe></p>
		</p><br/>
	</div>
</section>