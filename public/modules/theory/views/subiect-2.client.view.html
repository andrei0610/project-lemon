<section data-ng-controller="Subiect2Controller">
	<div id="content">
		<h2 class="text-center"> Subiectul II </h2>
		<span>Subiectul II cuprinde exercitii bazate pe teoria din:<a href="#subprog"> functii (subprograme) </a>, <a href="sub2-pag4.html">backtracking </a>, grafuri (<a href="sub2-pag5.html">neorientate</a> si <a href="sub2-pag6.html">orientate</a>) si <a href="sub2-pag7.html"> arbori</a>.</span>

		<h3 id="#subprog" class="text-center">1.Functii(subprograme)</h3>
		<p>O <em>funcţie</em> (<em>subprogram</em>) este un grup de instrucţiuni apelabil (invocabil) din alte părţi ale programului. De exemplu, <strong>main</strong> este o funcţie.<br/>
		A apela o funcţie înseamnă a o executa.<br/>
		Funcţiile ajută la modularizarea programului, la structurarea acestuia în unităţi logice.<br/>
		O funcţie se declară în felul următor:
		<pre>&#09&#09tip nume(lista_param); //Prototipul functiei</pre>
		Exemplu:
		<pre>&#09&#09int suma(int a, int b);</pre>
		<code>lista_param</code> - lista de parametri, despărţiţi prin virgulă, este opţională. <br/>
		Parantezele sunt obligatorii. Ele deosebesc funcţiile de alte entităţi C++ (de exemplu, variabile).
		<pre>&#09&#09void nimic(); //functie fara parametri</pre>
		Tipul <code>void</code> reprezintă absenţa tipului. Cu alte cuvinte, funcţiile care nu returnează nicio valoare, au tipul <code>void</code>.<br/>
		Funcţiile pot returna valori codului apelant (locul de unde a fost apelată funcţia) prin intermediul instrucţiunii <code>return</code>. <br/>
		După declarare, o funcţie trebuie definită undeva în program.
		<pre>&#09&#09#include &lt;iostream&gt;
		using namespace std;

		int suma(int, int); //Declarare

		int main()
		{
		    int x, y;
		    cout&lt;&lt;&quot;Da-mi doua numere intregi: &quot;;
		    cin &gt;&gt; x &gt;&gt; y;
		    cout&lt;&lt;&quot;Suma lor este &quot;&lt;&lt;suma(x, y);
		    return 0;
		}

		int suma(int a, int b) //Definire
		{
		    int rezultat=a + b;
		    //Puteam scrie direct
		    //return a+b;
		    return rezultat;
		}</pre>
		Când declaraţi o funcţie, puteţi omite numele parametrilor (aşa cum am făcut în exemplu), dar trebuie să precizaţi tipul lor. <br/>
		Parametrii sunt variabile locale funcţiei (vizibile numai în blocul funcţiei). <br/>
		Instrucţiunea <code>return</code> întrerupe execuţia funcţiei şi returnează valoarea expresiei, din dreapta, codului apelant. <br/>
		Într-o funcţie puteţi avea mai multe instrucţiuni <code>return</code>. <br/>
		Observaţi cum se apelează o funcţie: <code>suma(x, y);</code>.
		Dacă funcţia nu are parametri, se apelează doar cu nume + paranteze: <code>funcFaraParam();</code>.<br/>
		Când execuţia unei funcţii se termină, controlul programului revine în punctul apelării şi programul îşi continuă execuţia normal. <br/>
		Funcţiile <code>void</code> nu returnează valori, ele doar îndeplinesc o sarcină, deci nu pot avea instrucţiunea <code>return expr;</code>. <br/>
		Puteţi însă folosi <code>return;</code> ca să întrerupeţi execuţia unei funcţii <code>void</code>.
		<pre>&#09&#09#include &lt;iostream&gt;
		using namespace std;

		//Declarare + Definire
		void afiseazaText()
		{
		    for (int i=0; i &lt; 5; i++)
		        cout&lt;&lt;&quot;Hello functions!&quot;;
		}

		int main()
		{
		    //Se va afisa de 5 ori textul:
		    //Hello functions!
		    afiseazaText();
		    return 0;
		}</pre>
		Puteţi declara şi defini o funcţie în acelaşi loc, dar <strong>numai</strong> înainte de <strong>main</strong>, altfel compilatorul nu va recunoaşte funcţia. <br/>
		Funcţiile <code>void</code> nu pot fi folosite în expresii, deoarece expresiile au în componenţa lor operatori care aşteaptă valori, ori o funcţie <code>void</code> nu returnează nicio valoare. <br/>
		O funcţie poate avea orice număr de parametri. <br/>
		Variabilele declarate într-o funcţie sunt locale, adică sunt vizibile numai în respectiva funcţie. Ele nu pot fi folosite în afara ei (valabil şi pentru parametri). <br/>
		Argumentele funcţiei sunt datele (variabile, expresii, constante, etc.) transmise funcţiei şi primite de parametrii acesteia.<br/>
		De exemplu, în apelul <code>suma(x, y);</code> argumentele sunt variabilele <code>x</code> şi <code>y</code>. </p>
		<p>Parametrii unei funcţii pot avea valori implicite (default). Parametrii default trebuie poziţionaţi la sfârşitul listei de parametri.<br/>
		După ce aţi declarat un parametru implicit, nu mai aveţi voie să declaraţi parametri normali în continuare acestuia, ci doar parametri impliciţi.
		<pre>&#09&#09#include &lt;iostream&gt;
		using namespace std;

		double arieCerc(double raza, double PI=3.14)
		{
		    return 2*PI*raza*raza;
		}

		int main()
		{
		    cout&lt;&lt;&quot;Aria cercului de raza 2 este &quot;&lt;&lt;arieCerc(2.0)&lt;&lt;'\n'; //PI==3.14
		    cout&lt;&lt;&quot;Aria cercului de raza 2 este &quot;&lt;&lt;arieCerc(2.0, 3.141592);
		    return 0;
		}</pre>
		Se va afişa
		<pre>&#09&#09Aria cercului de raza 2 este 25.12
		Aria cercului de raza 2 este 25.1327</pre>
		Când nu transmiteţi o valoare parametrului implicit, compilatorul va folosi valoarea implicită, dată de voi.
<!--Aici incepe pagina 2. Schimba aici tagu pentru subiectu 2.-->


		<p><a class=""> Transmiterea prin valoare si prin referinta</a> </p>
		<p>Atunci când transmiteţi argumente (şi sunt variabile) unei funcţii, transmiteţi de fapt o copie a acelor variabile. <br/>
		Aceasta este transmiterea prin valoare (<em>pass by value</em>). <br/>
		Orice modificare a parametrilor unei funcţii este vizibilă numai în acea funcţie. <br/>
		Variabilele - folosite ca argumente - rămân nemodificate.
		<pre>&#09&#09#include &lt;iostream&gt;
		using namespace std;

		void modifica(int a)
		{
		    a=a + 5;
		    cout&lt;&lt;&quot;a are valoarea: &quot;&lt;&lt;a&lt;&lt;'\n';
		}

		int main()
		{
		    int x=1;
		    cout&lt;&lt;&quot;x inainte de apel: &quot;&lt;&lt;x&lt;&lt;'\n';
		    modifica(x);
		    cout&lt;&lt;&quot;x dupa apel: &quot;&lt;&lt;x;
		    return 0;
		}</pre>
		Output:
		<pre>&#09&#09x inainte de apel: 1
			a are valoarea: 6
			x dupa apel: 1</pre>
		O funcţie poate returna decât o singură valoare printr-un <code>return</code>, ca la matematică. <br/>
		Uneori vrem ca o funcţie să poată returna mai multe valori. Un mod prin care putem obţine acest lucru este transmiterea prin referinţă (<em>pass by reference</em>). <br/>
		Atunci când transmiteţi prin referinţă, parametrii funcţiei alterează direct conţinutul variabilelor argumente (nu mai există nicio copie). <br/>
		Ca să transmiteţi prin referinţă folosiţi ampersand (<code>&amp;</code>) între tipul parametrului şi numele acestuia. <br/>
		Parametrii referinţă acceptă numai variabile. <strong>NU</strong> acceptă constante (deoarece nu pot fi alterate)!
		<pre>&#09&#09#include &lt;iostream&gt;
		using namespace std;

		void modifica(int&amp; a) //Nu uitati de ampersand !
		{
		    a=a + 5;
		    cout&lt;&lt;&quot;a are valoarea: &quot;&lt;&lt;a&lt;&lt;'\n';
		}

		int main()
		{
		    int x=1;
		    cout&lt;&lt;&quot;x inainte de apel: &quot;&lt;&lt;x&lt;&lt;'\n';
		    modifica(x);
		    cout&lt;&lt;&quot;x dupa apel: &quot;&lt;&lt;x;
		    return 0;
		}</pre>
		Output:
		<pre>&#09&#09
		x inainte de apel: 1
		a are valoarea: 6
		x dupa apel: 6</pre>
		</p>

		<p>!<u> Observatie </u>: <strong>Vectorii</strong> se transmit prin referinţă! <br>
		<pre>&#09&#09#include &lt;iostream&gt;
		using namespace std;

		void modifica(int v[], int l)
		{
		    for (int i=0; i &lt; l; i++)
		        v[i] += 5; //v[i]=v[i] + 5;
		}

		int main()
		{
		    int w[]={1, 2, 3, 4}, k=4;
		    modifica(w, k);

		    for (int i=0; i &lt; k; i++)
		        cout &lt;&lt;w[i]&lt;&lt;' ';

		    return 0;
		}</pre>
		Output:
		<pre>&#09&#09 6 7 8 9</pre>
		Observaţi cum se transmite un vector ca parametru. <br/>
		Numărul de elemente poate lipsi (valabil doar pentru prima dimensiune). <br/>
		Dacă aş fi avut o matrice de <code>2 x 3</code>, atunci aş fi scris:
		<pre>&#09&#09void modifica(int v[][3],...)...</pre>
		</p><br/>

<!-- Aici incepe pagina 3 -->
		<div class="block">
		  <div class="label label-info">
		    <span>Functii recursive</span>
		  </div>
		</div>
		<span>O funcţie care se autoapelează se numeşte <em>recursivă</em>. <br/>
		Aveţi grijă ca funcţia să aibă o condiţie de terminare, altfel puteţi crea o repetiţie infinită. <br/>
		Parametrii funcţiilor şi variabilele locale sunt încărcate, stocate, pe Stivă (o regiune din memorie structurată pe principiul stivei, LIFO), iar în cazul unei funcţii recursive infinite, Stiva se poate umple repede (<em>stack overflow</em>) cauzând un crash al programului. <br/>
		Factorialul unui număr poate fi calculat cu o funcţie recursivă (deşi se poate face acelaşi lucru şi cu un loop).
		<pre>&#09&#09#include &lt;iostream&gt;
		using namespace std;

		int fact(int n)
		{
			//Conditia de terminare
		    if (n==0) 
		        return 1;
		    else
		        return n*fact(n-1);
		}

		int main()
		{
		    cout&lt;&lt;fact(0)&lt;&lt;'\n';
		    cout&lt;&lt;fact(3)&lt;&lt;'\n';
		    cout&lt;&lt;fact(8)&lt;&lt;'\n';
		    return 0;
		}</pre>
		Output:
		<pre>&#09&#09 
		1
		6
		40320</pre>
		Ca să înţelegeţi mai bine mecanismul recursivităţii vizionaţi acest clip de pe Youtube:
		<p style="text-align:center;"><iframe width="640" height="360" src="http://www.youtube.com/embed/k0bb7UYy0pY" frameborder="0" allowfullscreen></iframe></p>
		</span><br/>
<!-- Aici incepe pagina 4 -->
  		<h3 id="#backtracking" class="text-center">2.Backtracking</h3>
	 	<p><b> Backtracking </b> este o metoda de parcurgere sistematica a spatiului solutiilor posibile al unei probleme. <br>
		Este o metoda generala de programare, si poate fi adaptata pentru orice problema pentru care dorim sa obtinem toate solutiile posibile, sau sa selectam o solutie optima, din multimea solutiilor posibile. <br>
		Backtracking este insa si cea mai costisitoare metoda din punct de vedere al timpului de executie. </p>
	    <p> In general vom modela solutia problemei ca un vector <b> v=(v<sub>1</sub>, v<sub>2</sub>,...,v<sub>n</sub> )</b> in care fiecare element <b>v<sub>k</sub></b> apartine unei multimi finite si ordonate <b>S<sub>k</sub> cu k=1,n</b>. In anumite cazuri multimile <b>S<sub>1</sub>, S<sub>2</sub>,...,S<sub>n</sub></b> pot fi identice.<br>
		Procedam astfel: <br>
		<ol>
		<li> La fiecare pas k pornim de la o solutie partiala v=(v<sub>1</sub>, v<sub>2</sub>,...,v<sub>n</sub> ) si incercam sa extindem aceasta solutie adaugand un nou element la sfarsitul vectorului. </li>
		<li> Cautam in multimea S<sub>k</sub> un nou element.</li>
		<li> Daca exista un element neselectat inca, verificam daca acest element indeplineste conditiile impuse de problema, numite <b>conditii de continuare </b>.</li>
		<li> Daca sunt respectat conditiile de continuare, adaugam elementul solutiei partiale.</li>
		<li> Verificam daca am obtinut o solutie completa.
		       <ul style="list-style-type:square">
			     <li> daca am obtinut o solutie completa o afisam si se reia algoritmul de la pasul 1</li>
				 <li> daca nu am obtinut o solutie, k &lt;- k+1 si se reia algoritmul de la pasul 1</li>
			   </ul> </li>
	    <li> Daca nu sunt indeplinite conditiile de continuare se reia algoritmul de la pasul 2.</li>
		<li> Daca nu mai exista niciun element neverificat in multime S<sub>k</sub> inseamna ca nu mai avem nicio posibilitate din acest moment, sa construim solutia finala asa ca trebuie sa modificam alegerile facute in prealabil, astfel k&lt;-k-1 si se reia problema de la pasul 1.</li>
		</ol> <br>
		Revenirea in caz de insucces sau pentru generarea tuturor solutiilor problemei, a condus la denumirea de "backtracking" a metodei, traducerea aproximativa ar fi "revenire in urma".
		</p> <br>

		<div class="block">
		  <div class="label label-info">
		    <span>Exemplu: PERMUTARI</span>
		  </div>
		</div>
	    <p> Sa se genereze toate permutarile primelor <b>n</b> numere naturale. <br>
		 Vom selecta pe rand solutiile problemei in vectorul <b> v=(v<sub>1</sub>, v<sub>2</sub>,...,v<sub>n</sub> )</b> unde <b>v<sub>k</sub> </b> este din <b>S<sub>k</sub></b>. <br>
		 Sa facem urmatoarele observatii: 
		 <ol>
		 <li> Pentru aceasta problema toate multimile <b>S<sub>k</sub></b> sunt identice, cu <b>S<sub>k</sub>={1,2,3,...,n}</b>. La pasul <b>k</b> selectam un element din multimea <b>S<sub>k</sub></b>. </li>
		 <li> Intrucat in cadrul unei permutari <b> elementele nu au voie sa se repete </b> aceasta conditie reprezinta conditia de continuare a problemei. </li>
		 <li> Obtinem o solutie in momentul in care completam vectorul cu <b>n</b> elemente.</li>
		 </ol> 
	    </p>
	    <p> Exemplu pentru n=3.<br>
		<b>S<sub>1</sub> = S<sub>2</sub> = S<sub>3</sub> = {1,2,3}.</b> <br>
		Solutiile sunt: (1, 2, 3) (1, 3, 2) (2, 1, 3) (2, 3, 1) (3, 1, 2) (3, 2, 1). <br>
		<!-- Din nu stiu care motiv, nu merge srcu asta. -->
		<img src="/modules/theory/images/permutari.png"></img>
		</p>
<!-- Aici incepe pagina 5. -->
		<h3 id="#grafuri" class="text-center">3.Grafuri</h3>
		<div class="block">
		  <div class="label label-info">
		    <span>Grafuri neorientate</span>
		  </div>
		</div>
		<p>
		Definitie: Se numeste <b>graf neorientat</b> G o pereche ordonata de multimi (X,U), unde X este o multime finita si nevida de elemente, iar U o multime de perechi formate cu elemente distincte din multimea X.
	    <br>
		G= (V,U) <br>
		<u>Exemplu </u>: <br>
		V = {1,2,3,4,5,6,7} <br> U = {(1,2),(2,3),(3,7),(7,5),(1,6),(7,1),(2,5),(2,7)} <br>
		
		<img src="/modules/theory/images/ex-graf-neorientat.jpg" > Fig.1  </img>
		</p>
		
		<p>
		<div class="block">
		  <div class="label label-warning">
		    <span>Terminologie</span>
		  </div>
		</div>
		<ul style="list-style-type:circle">
		<li> Elementele multimii V se numesc <b> noduri </b> sau <b>varfuri </b>. Multimea V se mai numeste si multimea nodurilor sau varfurilor. </li>
		<li> Elementele multimii U se numesc <b>muchii</b>. Multimea U se mai numeste si multimea muchiilor.</li>
		<li> Ordinul grafului reprezinta numarul de noduri ale grafului. </li>
		<li> Numim <b>noduri adiacente</b> orice pereche de noduri care formeaza o muchie. Fiecare din cele doua noduri spunem, ca sunt incidente cu muchia pe care o formeaza.</li>
	     <br>
		Exemplu: <br>
		Nodul 1 este adiacent cu nodurile 2,6,7; nodul 5 este adiacent cu nodurile 2,7 etc. <br>
		Nodurile 3,7 sunt incidente cu muchia (3,7). <br> <br>
	    <li> Nodurile <b>vecine </b> ale unui nod sunt toate nodurile adiacente cu el. </li>
		<li> Se numesc muchii incidente doua muchii care au extremitate comuna.</li> <br>
		Exemplu: <br>
		Muchiile (1,2) si (2,7) sunt incidente avand ca extremitate comuna nodul 2. 
		</ul> <br><br>
		<u> Definitie  </u> :<b>Gradul unui nod x </b> al grafului este egal cu numarul muchiilor incidente cu nodul si se noteaza cu <b>d(x) </b>.
	    <br>
		Exemplu: <br>

	    d(1)=3;d(2)=4;d(3)=2 etc. (Fig.1)<br><br>
		<li> Se numeste <b>nod terminal </b> un nod care are gradul egal cu 1. </li>
		<li> Se numeste un <b>nod izolat</b> un nod care are gradul 0. </li>
		</ul>
		</p>
		
		<div class="block">
		  <div class="label label-warning">
		    <span>Teoreme</span>
		  </div>
		</div>
		<ol>
		<li> Numarul total de grafuri neorientate cu n noduri este: <br> <img src="/modules/theory/images/gr-neor-1.jpg"></img></li>
		<li> Suma gradelor tuturor nodurilor unui garf neorientat este egala cu dublul nuamrului de muchii. <br> <img src="/modules/theory/images/gr-neor-2.jpg"></img></li>
		<li> Daca gaful G neorientat are n noduri, n>2, atunci cel putin 2 noduri au acelasi grad.   </li>
		<li> Pentru orice graf neorientat numarul nodurilor de gard impar este par.</li>
		<li> Numarul minim de muchii pe care trebuie sa le aiba n graf neorientat cu n noduri, ca sa nu existe noduri izolate este: <br> <img src="/modules/theory/images/gr-neor-5.jpg"></img> </li>
		</ol>
		</p>

		<div class="block">
		  <div class="label label-warning">
		    <span>Lanturi intr-un graf neorientat</span>
		  </div>
		</div>
		<u>Definitie </u>: Se numeste <b>lant</b> intr-un graf neorientat o succesiune de varfuri cu proprietatea ca intre oricare doua varfuri alaturate exista o muchie. 
		<br>
		Exemplu: <br> {6,1,7,5,2,3} reprezinta un  lant. (Fig.1)<br><br>
		
		<div class="block">
		  <div class="label label-warning">
		    <span>Terminologie</span>
		  </div>
		</div>
		<ul style="list-style-type:circle">
		<li> Numim <b>lant elementar </b> o succesune de varfuri care respecta proprietatea de lant si in care oricare doua varfuri sunt distincte. In caz contrar lantul se numeste <b>neelementar</b>.</li>
		<li> Se numeste <b>lant simplu </b> o succesiune de  varfuri cu proprietatea ca fiecare muchie este vizitata o singura data. </li>
		<li> Se numeste lant <b>compus</b> un lant in care o muchie este vizitata de cel putin doua ori. </li>
		<li> Se numeste <b>ciclu </b> int-un lant o succesiune de varfuri cu proprietatea ca primul nod coincide cu ultimul nod.</li>
		
		</ul>
		<br>
		
	    Exemplu:  <br>

	   {6,1,7,2} reprezinta un lant elementar. <br>

	  {6,1,7,5,2,7,3} reprezinta lant neelementar. <br>

	  {2,3,7,5} reprezinta lant simplu. <br>

	  {5,2,7,5,2,3} reprezinta lant compus. <br>

	  {5,2,7,5} reprezinta ciclu intr-un lant. (Fig.1)
		
		</p> <br>
		
		<p>
		<div class="block">
		  <div class="label label-warning">
		    <span>Grafuri derivate</span>
		  </div>
		</div>
		<u>Definitie </u>: Se numeste <b>graf partial </b> notat cu Gp=(V,U'), cu proprietatea ca multimea U' de perechi de varfuri este inclusa in multimea U.
		<br>
		G={V,U} <br>

	   V={1,2,3,4,5,6,7} <br>

	   U={(1,6),(1,7),(2,3),(2,5),(3,7),(5,7)} <br>
	   <img src="/modules/theory/images/ex-graf-neorientat.jpg"> </img> <br>
	   
	   <u> Definitie </u>: Un <b>subgraf</b> al unui graf neorientat G=(V,U) este un graf H=(V',U') astfel incât V' inclus in V şi U' conţine toate muchiile din U care au ambele extremităţi în V' (poate fi graful iniţial sau se obţine din acesta prin eliminarea unor vârfuri şi a muchiilor incidente cu acestea). 
		
		</p> <br>
		<div class="block">
		  <div class="label label-warning">
		    <span>Grafuri speciale</span>
		  </div>
		</div>	
		<b>Graful null </b> este garful in care multimea U este vida. <br>
		<img src="/modules/theory/images/graf-neor-null.jpg"> </img> <br>
		<b>Graful complet cu n noduri </b> este graful care are intre oricare doua noduri adiacente o muchie  .<br>
		<img src="/modules/theory/images/graf-neor-complet.jpg"> </img> <br>
		<b>Graful conex </b> este un graf care are intre oricare doua noduri un lant care sa le uneasca. <br>
		<img src="/modules/theory/images/graf-neor-conex.jpg"> </img>
		</p>

<!-- Aici incepe pagina 6. -->
		<h3 id="#grafuri" class="text-center">3.Grafuri</h3>
		<div class="block">
		  <div class="label label-info">
		    <span>Grafuri orientate</span>
		  </div>
		</div>
		<p>
		<u> Definitie </u>:  Se numeste <b>graf orientat</b> sau digraf (G) o pereche ordonata de multimi (X,U), unde X este o multime finita si nevida de elemente, iar U o multime de perechi ordonate formate cu elemente distincte din multimea X.
		<br>
		<img src="/modules/theory/images/ex-graf-orientat.jpg"> </img> <br>
		<img src="/modules/theory/images/gr-or-matrice.jpg"> </img> <br>
		Elementele multimii U se numesc <b>arce </b>. Multimea U se mai numeste si <b> multimea arcelor </b>. <br>
		Numim <b>varfuri adiacente </b> orice pereche de varfuri care formeaza un arc .Fiecare din cele doua varafuri spunem ca sunt incidente cu arcul pe care il formeaza. <br>
		Pentru arcul (x,y) spunem ca x este extremitatea initiala iar y este extremitatea finala. <br>
		Se numesc <b>arce incidente</b> doua arce care au o extremitate comuna. <br><br>
		Se numeste <b>succesor</b> al varfului x oirce varf  la care ajunge un arc care iese din varful x. <br>
		Se numeste <b>predecesor </b>  al varfului x orice varf la care intra un arc  in varful x. <br><br>
		Se numeste <b>nod sursa al grafului </b>, nodul care are multimea succesorilor formata din toate celelalte noduri mai putin el, iar multimea predecesorilor este vida.
		<br> <b>Nodul destinatie al unui graf </b> este nodul care are multimea predecesorilor formata din toate celelalte noduri mai putin el ia rmultimea succesorilor este vida. 
		<br><br>
		<b>Gradul intern unui nod x </b> al grafului G este egal cu numarul arcelor care intra in nodul x si se noteaza cu d-(x).  <br>
		<b>Gradul extern unui nod x </b> al grafului G este egal cu numarul arcelor care ies din nodul X si se noteaza cu d+(x). <br>
		<img src="/modules/theory/images/gr-or-grad1.jpg"> </img>
		Grad intern <img src="/modules/theory/images/gr-or-grad-intern.jpg"> </img>
		Grad extern<img src="/modules/theory/images/gr-or-grad-extern.jpg">  </img> <br>
		Se numeste  <b>nod terminal</b> un nod care are suma gradelor egala cu 1. <br>
		Se numeste <b> nod izolat </b> un nod cera are suma gradelor egal. <br><br>
		<div class="block">
		  <div class="label label-warning">
		    <span>Teorema</span>
		  </div>
		</div>
		Intr-un garf orientat cu n varfuri, suma gradelor interne ale tuturor nodurilor este egala cu suma gradelor exterioare ale tuturor nodurilor si cu numarul de arce. 
		<br><br>
		<div class="block">
		  <div class="label label-warning">
		    <span>Grafuri speciale</span>
		  </div>
		</div>
		Graful G se numeste <b>graf nul</b> daca multimea U este vida, adica graful nu are muchii.
		<br>
		Un graf cu n noduri se numeste <b>complet</b> daca are proprietatea ca oricare ar fi doua noduri ale grafului ele sunt adiacente .
		<br><br>
		<div class="block">
		  <div class="label label-warning">
		    <span>Conexitate</span>
		  </div>
		</div>
		Numim <b>lant</b> o succesiune de noduri care au proprietatea ca oricare ar fi doua noduri succesive, ele sunt adiacente.
		<br>
		Numim <b>ciclu</b> un lant in care toate muchiile/arcele sunt distincte doua cate doua si primul nod coincide cu ultimul .
		<br>
		Un graf fara cicluri se numeste <b>graf aciclic</b> .
		<br>
		Numim <b>drum</b> o succesiune de noduri care au proprietatea ca oricare ar fi doua noduri  succesive ele sunt legate printr-un arc.
		<br>
		Numim <b>circuit</b> un drum in care toate arcele sunt distincte doua cate doua si ale carui extremitati coincid.
		<img src="/modules/theory/images/gr-or-lant.jpg"> </img> <br><br>
		<div class="block">
		  <div class="label label-warning">
		    <span>Terminologie</span>
		  </div>
		</div>
		<b>Lungimea unui lant</b> reprezinta numarul de muchii/arce din care este format. <br>
		<b>Lantul simplu</b> este lantul care contine numai muchii/arce distincte ..<br>
		<b>Lantul compus</b> este lantul care nu este format din muchii/arce distincte. <br>
		<b>Lantul elementar</b> este lantul care contine numai noduri distincte. <br>
		<b>Ciclu elementar</b> este un ciclu in care toate nodurile sunt distincte doua cate doua (cu exeptia primului si ultimului nod).<br>
		<b> Lungimea unui drum </b> este data de numarul de arce pe arce il compun. <br>
		<b>Drumul simplu </b> este drumul care contine numai arce distincte. <br>
		<b>Drumul compus </b> este drumul care nu este format numai din arce distincte. <br>
		<b>Drumul elementar </b> este drumul in care nodurile sunt distincte doua cate doua. <br>
		<b>Circuitul elementar </b> este circuitul in care toate nodurile sunt distincte doua cate doua cu exceptia primultui si a ulitmului care coincid.
		<br><br>

		<div class="block">
		  <div class="label label-warning">
		    <span>Teoreme</span>
		  </div>
		</div>
		<ol>
		<li>Daca un graf contine un lant intre doua noduri x si y atunci contine un lant elementar intre nodurile x si y. </li>
		<li> Daca un graf contine un drum intre doua noduri x si y atunci contine un drum elementar intre nodurile x si y </li>
		<li> Daca un graf contine un ciclu atunci contine si un ciclu elementar .</li>
		<li> Daca un graf contine un circuit atunci contine si un circuit elementar. </li>
		</ol>
		<br><br>
		<div class="block">
		  <div class="label label-warning">
		    <span>Definitii</span>
		  </div>
		</div>
		Un graf G se numeste <b>graf conex</b> daca are proprietatea ca pentru orice pereche de de noduri diferite intre ele exista un lant care sa le lege.
		<br> <img src="/modules/theory/images/gr-or-conex.jpg"> </img> <br>
		Daca un graf G nu este conex se numeste <b>componenta conexa a grafului </b> un subgraf conex al sau, maximal in raport cu aceasta proprietate (contine numarul maxim de noduri din G care ua proprietatea ca sunt legate cu un lant). <br>
		Un graf conex are o singura componenta conexa. <br>
		Un graf orientat G se numeste <b>graf tare conex</b> daca are proprietatea ca pentur orice pereche de noduri x si y, diferite intre ele, exista un drum de la nodul x spre nodul y si exista drum de la nodul y la nodul x. <br>
		Daca un graf orientat g nu este tare conex se numeste <b>componenta tare conexa a grafului</b>, un subgraf tare conex al sau,maximal in raport cu aceasta proprietate (contine numarul maxim de noduri din g care au proprietatea ca sunt legate printr-un drum in ambele sensuri).
		<br><br>
		<div class="block">
		  <div class="label label-warning">
		    <span>Teoreme</span>
		  </div>
		</div>
		<ol>
		<li> Numarul minim de muchii necesare ca pentru un graf neorientat sa fie conex este <b>n-1</b> .</li>
		<li> Un graf conex cu n noduri si n-1 muchii este <b>aciclic</b> si <b>maximal</b> cu aceasta proprietate .</li>
		<li> Daca un graf neorientat conex are n noduri si m muchii, numarul de muchii care trebuie eliminate pentru a obtine un graf partial conex aciclic este <b>m-n+1 </b>.</li>
		<li> Daca un graf are n noduri, m muchii si p componente conexe, numarul de muchii care trebuie eliminate pentru a obtine un graf partial aciclic(arbore) este egal cu <b>m-n+p</b> .</li>
		<li> Pentru a obtine dintr-un graf neorientat conex, 2 componente conexe, numarul minim de muchii care trebuie eliminate este cel mult egal cu gradul minim din graf.</li>
		<li> Numarul maxim de muchii dintr-un graf neorientat cu n noduri si p componente conexe este:  <br><b> (n-p)*(n-p+1)/2 </b> .</li>
		</ol> <br>

		<div class="block">
		  <div class="label label-warning">
		    <span>Definitii</span>
		  </div>
		</div>
		Numim <b>lant hamiltonian</b> un lant elememntar ce contine toate nodurile grafului. <br>
		Numim <b>ciclu hamiltoniann</b> un ciclu elementar ce contine toate nodurile grafului. <br>
		Un graf ce contine un ciclu hamiltonian se numeste <b>graf hamiltonian </b>. <br>
		Numim <b>ciclu eulerian </b> un ciclu ce contine toate muchiile grafului. <br>
		Un graf ce contine un ciclu eulerian se numeste <b>graf eulerian</b>. <br>
		Un graf orientat in care, intre oricare doua noduri exista un singur arc si numai unul se numeste <b>graf turneu</b>. 
		<br><br>

		<div class="block">
		  <div class="label label-warning">
		    <span>Teoreme</span>
		  </div>
		</div>
		<ol>
		<li>Un graf cu mai mult de 2 noduri este hamiltonian daca gradul fiecarui nod este &ge; n/2.  </li>
		<li> Un graf ce nu contine grafuri izolate este eulerian daca si numai daca este conex si gradele tuturor nodurilor sunt pare. </li>
		<li> Numarul de cicluri hamiltoniene dintr-un graf complet cu n noduri este (n-1)!/2. </li>
		<li> Orice graf turneu contine un drum elementar care trece prin toate nodurile grafului.</li>
		<li> Pentru orice graf turneu, exista un nod x, astfel incat toate nodurile y != x sunt accesibile din x pe un drum care contine un arc sau doua arce.</li>
		</ol>
<!-- Manastrire intr-un picior, bag pula in ei de tigani. -->
<!-- Aici incepe pagina 7 -->
		<h3 id="#arbori" class="text-center">3.Arbori</h3>
		<div class="block">
		  <div class="label label-info">
		    <span>Definitii</span>
		  </div>
		</div>
		Se numeste <b>arbore</b> un graf neorientat, conex si fara cicluri. <br>
		In continuare se vor lua în discutie arborii cu radacina. În cazul arborilor cu radacina se pune în evidenta un varf special al sau numit radacina. Alegerea radacinii duce la asezarea arborelui pe nivele astfel:
		<ul style="list-style-type:circle">
		  <li>	se aseaza radacina pe nivelul 1 (acest nivel se noteaza în multe lucrari de specialitate cu 0) </li>
		  <li>	pe fiecare nivel k (k&gt;1) se plaseaza acele varfuri pentru care lungimea lanturilor care le leaga de radacina este k-1 </li>
		  <li>	se traseaza muchiile arborelui </li>
		</ul>
		Nodurile adiacente cu radacina se numesc <b>descendentii radacinii </b>. Conceptul se aplica analog pentru nodurile de pe un alt nivel. <br>
		Descendentii aceluiasi nod se numesc <b>frati </b>. <br>
		Daca nodul x este descendentul unui nod y, îl numim pe acesta din urma <b>parintele</b> nodului x. <br>
		Intr-un arbore cu rădăcină, nodul x este <b>frunza</b> dacă nu are niciun descendent direct. <br>
		Se numeste <b>inaltimea unui arbore</b> diferenta dintre nivelul maxim din arbore si nivelul minim (nivelul radacinii). <br> <br> 
		<img src="/modules/theory/images/arbore.gif" style="float:left; margin:5px 50px 5px 80px;"> </img>
		Nodul 1 este radacina. <br>
		Nodurile 5, 6, 7 sunt fii nodului 3. <br>
		Nodul 7 este parintele nodurilor 9 şi 10. <br>
		Nodul 9 este descendentul lui 3. <br>
		Nodul 3 este ascendentul lui 10. <br>
		Nodurile 8, 9 şi 10 sunt frunze. <br>
		Nodurile 5, 6 şi 7 sunt frati. <br> <br>

		<div class="block">
		  <div class="label label-warning">
		    <span>Reprezentare</span>
		  </div>
		</div>
		Arborii se pot reprezenta prin: 
		<ol>
		<li> Metode specifice grafurilor: 
		       <ul style="list-style-type:circle"> 
			     <li> matricea de adiacenta </li>
				 <li> liste de adiacenta </li>
			   </ul></li>
		<li> Metode specifice arborilor: 
			<ul style="list-style-type:circle"> <li> prin legaturi de tip <i> tata </i>; arborele se reprezinta sub forma unui vector t cu n componente (n reprezinta numarul de noduri); daca t[i]=k atunci nodul I este descendent al nodului k ; daca nodul I este varf atunci t[i]=0.
		</li></ul>
		</li>
		</ol>
		Exemplu pentru arborele din figura anterioara: <br> <br>
		<table class="table table-bordered">
		<tr>
		  <th> Nodul (i): </th>
		  <th> 1 </th>
		  <th> 2 </th>
		  <th> 3 </th>
		  <th> 4 </th>
		  <th> 5 </th>
		  <th> 6 </th>
		  <th> 7 </th>
		  <th> 8 </th>
		  <th> 9 </th>
		  <th> 10 </th>
		</tr>
		<tr> 
		  <td> Tatal ( t[i] ):  </td>
		  <td> 0 </td>
		  <td> 1 </td>
		  <td> 1 </td>
		  <td> 1 </td>
		  <td> 3 </td>
		  <td> 3 </td>
		  <td> 3 </td>
		  <td> 4 </td>
		  <td> 7 </td>
		  <td> 7 </td>
		</tr>
		</table>	
		</p>
		</p>
	</div>
</section>